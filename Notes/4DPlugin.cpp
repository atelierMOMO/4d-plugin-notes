/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Notes
 #	author : miyako
 #	2017/09/05
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#pragma mark DateFormatter

namespace DateFormatter
{
	NSDateFormatter *ISO;
	NSDateFormatter *GMT;
	
	void setup()
	{
		GMT = [[NSDateFormatter alloc]init];
		[GMT setDateFormat:DATE_FORMAT_ISO_GMT];
		[GMT setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];
		
		ISO = [[NSDateFormatter alloc]init];
		[ISO setDateFormat:DATE_FORMAT_ISO];
		[ISO setTimeZone:[NSTimeZone localTimeZone]];
	}
	
	void clear()
	{
		[GMT release];
		[ISO release];
	}
	
}

#pragma mark JSON

#if VERSIONMAC
NSString *json_conv(json_char *src)
{
	C_TEXT t;
	
	if(src)
	{
		std::wstring wstr = std::wstring(src);
		
		uint32_t dataSize = (uint32_t)((wstr.length() * sizeof(PA_Unichar)) + sizeof(PA_Unichar));
		std::vector<char> buf(dataSize);
		
		PA_ConvertCharsetToCharset((char *)wstr.c_str(),
															 (PA_long32)(wstr.length() * sizeof(wchar_t)),
															 eVTC_UTF_32,
															 (char *)&buf[0],
															 dataSize,
															 eVTC_UTF_16);
		
		//don't use len, null chars matter
		CUTF16String u16 = (const PA_Unichar *)&buf[0];
		t.setUTF16String(&u16);
	}
	return t.copyUTF16String();
}

NSString *json_copy_text(JSONNODE *n, const wchar_t *name)
{
	NSString *t = nil;
	
	if(n)
	{
		if(name)
		{
			json_char *json_string = json_as_string(json_get(n, name));
			t = json_conv((json_char *)json_string);
			json_free(json_string);
		}
	}
	return t ? t : @"";
}
#endif

void json_set_text(JSONNODE *n, const wchar_t *name, C_TEXT &t)
{
	if(n)
	{
		if(name)
		{
			uint32_t dataSize = (t.getUTF16Length() * sizeof(wchar_t))+ sizeof(wchar_t);
			std::vector<char> buf(dataSize);
			PA_ConvertCharsetToCharset((char *)t.getUTF16StringPtr(),
																 t.getUTF16Length() * sizeof(PA_Unichar),
																 eVTC_UTF_16,
																 (char *)&buf[0],
																 dataSize,
																 eVTC_UTF_32);
			json_push_back(n, json_new_a(name, (wchar_t *)&buf[0]));
		}else
		{
			JSONNODE *node = json_new_a(name, L"");
			json_nullify(node);
			json_push_back(n, node);
		}
	}
}

void json_set_text(JSONNODE *n, const wchar_t *name, NSString *value)
{
	if((n))
	{
		if(name)
		{
			C_TEXT t;
			t.setUTF16String(value);
			
			uint32_t dataSize = (t.getUTF16Length() * sizeof(wchar_t))+ sizeof(wchar_t);
			std::vector<char> buf(dataSize);
			PA_ConvertCharsetToCharset((char *)t.getUTF16StringPtr(),
																 t.getUTF16Length() * sizeof(PA_Unichar),
																 eVTC_UTF_16,
																 (char *)&buf[0],
																 dataSize,
																 eVTC_UTF_32);
			json_push_back(n, json_new_a(name, (wchar_t *)&buf[0]));
		}else
		{
			JSONNODE *node = json_new_a(name, L"");
			json_nullify(node);
			json_push_back(n, node);
		}
	}
}

void json_set_date(JSONNODE *n, const wchar_t *name, NSDate *value, BOOL isGMT = YES)
{
	if(isGMT)
	{
		json_set_text(n, name, value ? [DateFormatter::GMT stringFromDate:value] : @"");
	}else
	{
		json_set_text(n, name, value ? [DateFormatter::ISO stringFromDate:value] : @"");
	}
}

void json_stringify(JSONNODE *json, C_TEXT &t, BOOL pretty = NO)
{
	json_char *json_string = pretty ? json_write_formatted(json) : json_write(json);
	std::wstring wstr = std::wstring(json_string);
	uint32_t dataSize = (uint32_t)((wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar));
	std::vector<char> buf(dataSize);
	PA_ConvertCharsetToCharset((char *)wstr.c_str(),
														 (PA_long32)(wstr.length() * sizeof(wchar_t)),
														 eVTC_UTF_32,
														 (char *)&buf[0],
														 dataSize,
														 eVTC_UTF_16);
	CUTF16String u16 = (const PA_Unichar *)&buf[0];
	t.setUTF16String(&u16);
	json_free(json_string);
}

namespace Notes
{
	static NotesApplication *Application = [SBApplication applicationWithBundleIdentifier:NOTES_APP_ID];
	static NSString *absolutePath = [[NSWorkspace sharedWorkspace]absolutePathForAppBundleWithIdentifier:NOTES_APP_ID];
	static NSBundle *bundle = [NSBundle bundleWithPath:absolutePath];
	
	//scpt
	NSString *script =
	@"on add_attachment(note_id, attachment_path) \n\
	tell application \"Notes\" \n\
	set the_note to note id note_id \n\
	set the_attachment to make new attachment at the_note with data attachment_path \n\
	end tell \n\
	end add_attachment";
	
	bool isScriptCompiled = NO;
	
	NSAppleScript *scriptObject = nil;
	
//  this doesn't work...
//	NSBundle *Bundle = [NSBundle bundleWithIdentifier:NOTES_APP_ID];
	
#pragma mark Notes
	
	void setup()
	{
		scriptObject = [[NSAppleScript alloc]initWithSource:script];
		isScriptCompiled = [scriptObject compileAndReturnError:nil];
	}
	
	void clear()
	{
		[scriptObject release];
	}
	
#pragma mark Private
	
	NSString *_uuidString()
	{
		return [[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""];
	}
	
	NotesNote *_getNote(JSONNODE *json)
	{
		NotesNote *note = nil;
		
		SBElementArray *notes = [Notes::Application notes];
		
		NSArray *noteIds = [notes arrayByApplyingSelector:@selector(id)];
		
		if([noteIds count])
		{
			NSString *noteId = json_copy_text(json, L"id");
			
			NSUInteger i = [noteIds indexOfObjectPassingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop)
											{
												if ([(NSString*)obj isEqualToString:noteId])
												{
													return YES;
												}
												return NO;
											}];
			
			if(NSNotFound != i)
			{
				note = [notes objectWithID:noteId];
			}
			[noteId release];
		}
		
		return note;
	}
	
	NotesFolder *_getFolder(JSONNODE *json)
	{
		NotesFolder *folder = nil;
		
		SBElementArray *folders = [Notes::Application folders];
		
		NSArray *folderIds = [folders arrayByApplyingSelector:@selector(id)];

		if([folderIds count])
		{
			NSString *folderId = json_copy_text(json, L"folder");
			
			NSUInteger i = [folderIds indexOfObjectPassingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop)
											{												
												if ([(NSString*)obj isEqualToString:folderId])
												{
													return YES;
												}
												return NO;
											}];
			
			if(NSNotFound != i)
			{
				folder = [folders objectWithID:folderId];
			}
			[folderId release];
		}

		return folder;
	}

	void _getFolders(JSONNODE *json)
	{
		JSONNODE *folders_array = json_new(JSON_ARRAY);
		
		SBElementArray *folders = [Notes::Application folders];
		NSArray *folderNames = [folders valueForKey:@"name"];
		NSArray *folderIds = [folders valueForKey:@"id"];
		for(NSUInteger i = 0; i < [folderIds count]; ++i)
		{
			JSONNODE *item = json_new(JSON_NODE);
			
			NSString *folderName = NSLocalizedStringFromTableInBundle([folderNames objectAtIndex:i], nil, bundle, nil);
			NSString *folderId = [folderIds objectAtIndex:i];
			
			json_set_text(item, L"name", folderName);
			json_set_text(item, L"id", folderId);
			
			json_push_back(folders_array, item);
		}
		json_set_name(folders_array, L"folders");
		json_push_back(json, folders_array);
	}
	
	void _createNote(JSONNODE *json)
	{
		NotesFolder *folder = _getFolder(json);
		
		if(folder)
		{
			NSString *title = json_copy_text(json, L"title");
			NSString *body = json_copy_text(json, L"body");
	
			NSDictionary *notes_props = [[NSDictionary alloc]initWithObjectsAndKeys:
																	 title, @"name",
																	 body, @"body",
																	 nil];
			[title release];
			[body release];
			
			NotesNote *note = [[[Notes::Application classForScriptingClass:@"note"]alloc]
												 initWithProperties:notes_props];
			[notes_props release];
			
			[[folder notes]addObject:note];
			
			json_set_text(json, L"id", note.id);
			json_set_date(json, L"creationDate", note.creationDate);
			json_set_date(json, L"modificationDate", note.modificationDate);
			json_set_date(json, L"creationLocalDate", note.creationDate, NO);
			json_set_date(json, L"modificationLocalDate", note.modificationDate, NO);
			
			[note release];
			
//			[Notes::Application activate];
		}
		
	}
	
#pragma mark Public
	
	void addAttachment(NotesNote *note, NSData *data, NSString *name)
	{
		NSArray *URLs = [[NSFileManager defaultManager]
										 URLsForDirectory:NSLibraryDirectory
										 inDomains:NSUserDomainMask];
		
		if(URLs && [URLs count])
		{
			NSURL *libraryDirectory = [URLs objectAtIndex:0];
			NSURL *containerDirectory = [libraryDirectory URLByAppendingPathComponent:@"Group Containers"];
			NSURL *groupDirectory = [containerDirectory URLByAppendingPathComponent:@"group.com.apple.notes"];
			NSURL *mediaDirectory = [groupDirectory URLByAppendingPathComponent:@"Media"];
			NSURL *uniqueDirectory = [mediaDirectory URLByAppendingPathComponent:_uuidString()];
			NSURL *dstPath = [uniqueDirectory URLByAppendingPathComponent:name];
			
			if([[NSFileManager defaultManager]createDirectoryAtURL:uniqueDirectory
															withIntermediateDirectories:YES attributes:nil error:nil])
			{
				if([data writeToURL:dstPath atomically:NO])
				{
				
					/*
					NSString *script = [[NSString alloc]initWithFormat:
															@"tell application \"%@\" \n\
															set %@ to note id \"%@\" \n\
															set %@ to make new attachment at %@ with data \"%@\" \n\
															end tell",
															@"Notes",
															@"the_note", note.id,
															@"the_attachment", @"the_note", [dstPath path]];
					
					NSLog(@"%@", script);
					
					NSAppleScript *scriptObject = [[NSAppleScript alloc]initWithSource:script];
				
					if([scriptObject compileAndReturnError:nil])
					{
						NSAppleEventDescriptor *returnValue = [scriptObject executeAndReturnError:nil];
						NSLog(@"%@", returnValue);
					}
					[scriptObject release];
					[script release];
					*/
					
					NSAppleEventDescriptor *parameters = [NSAppleEventDescriptor listDescriptor];
					NSAppleEventDescriptor *param_note_id = [NSAppleEventDescriptor descriptorWithString:note.id];
					[parameters insertDescriptor:param_note_id atIndex:1];
					NSAppleEventDescriptor *param_attachment_path = [NSAppleEventDescriptor descriptorWithString:[dstPath path]];
					[parameters insertDescriptor:param_attachment_path atIndex:2];
					
					ProcessSerialNumber psn = {0, kCurrentProcess};
					NSAppleEventDescriptor *target =
					[NSAppleEventDescriptor
					 descriptorWithDescriptorType:typeProcessSerialNumber
					 bytes:&psn
					 length:sizeof(ProcessSerialNumber)];
			
					NSAppleEventDescriptor *handler = [NSAppleEventDescriptor descriptorWithString:@"add_attachment"];
					
					NSAppleEventDescriptor *event =
					[NSAppleEventDescriptor appleEventWithEventClass:kASAppleScriptSuite
																									 eventID:kASSubroutineEvent
																					targetDescriptor:target
																									returnID:kAutoGenerateReturnID
																						 transactionID:kAnyTransactionID];
				
					[event setParamDescriptor:handler forKeyword:keyASSubroutineName];
					[event setParamDescriptor:parameters forKeyword:keyDirectObject];
					
					if(isScriptCompiled)
					{
						[scriptObject executeAppleEvent:event error:nil];
					}
				
					//cleanup
					if([[NSFileManager defaultManager]removeItemAtPath:[dstPath path] error:nil])
					{
						[[NSFileManager defaultManager]removeItemAtPath:[uniqueDirectory path] error:nil];
					}
				}
			}
		}
	}
	
	void getFolder(C_TEXT &folder)
	{
		JSONNODE *json = json_new(JSON_NODE);
		json_set_text(json, L"folder", folder);
		_getFolder(json);
		json_delete(json);
	}
	
	void getFolders(C_TEXT &folders)
	{
		JSONNODE *json = json_new(JSON_NODE);
		_getFolders(json);
		json_stringify(json, folders);
		json_delete(json);
	}
	
	void createNote(PackagePtr pParams, sLONG_PTR *pResult)
	{
		C_TEXT folder;
		C_TEXT title;
		C_TEXT body;
		C_TEXT result;
		
		folder.fromParamAtIndex(pParams, 1);
		title.fromParamAtIndex(pParams, 2);
		body.fromParamAtIndex(pParams, 3);
		
		JSONNODE *json = json_new(JSON_NODE);
		json_set_text(json, L"folder", folder);
		json_set_text(json, L"title", title);
		json_set_text(json, L"body", body);
	
		_createNote(json);
		
		NotesNote *note = _getNote(json);
		
		if(note)
		{
			PA_Variable *attachments = ((PA_Variable *)pParams[3]);//$4
			PA_Variable *filenames = ((PA_Variable *)pParams[4]);//$5
			
			if((attachments->fType == eVK_ArrayBlob) && (filenames->fType == eVK_ArrayUnicode))
			{
				unsigned int param4_count = PA_GetArrayNbElements(*attachments);
				unsigned int param5_count = PA_GetArrayNbElements(*filenames);
			
				if(param4_count == param5_count)
				{
					for(unsigned int i = 0; i <= param4_count; ++i)
					{
						PA_Blob param4_blob = PA_GetBlobInArray(*attachments, i);
						const void *param4_buf = (const void *)PA_LockHandle(param4_blob.fHandle);
						NSUInteger param4_len = (NSUInteger)param4_blob.fSize;
						if(param4_len)
						{
							NSData *data = [[NSData alloc]initWithBytes:param4_buf length:param4_len];
							PA_Unistring param5_text = PA_GetStringInArray(*filenames, i);
							NSString *name = [[NSString alloc]initWithCharacters:param5_text.fString length:param5_text.fLength];
							
							addAttachment(note, data, name);
							
							[name release];
							[data release];
						}
						PA_UnlockHandle(param4_blob.fHandle);
					}
				}
			}
		}
	
		json_stringify(json, result);
		json_delete(json);
		
		result.setReturn(pResult);
	}
}

#pragma mark -

void OnStartup()
{
	DateFormatter::setup();
	Notes::setup();
}

void OnExit()
{
	DateFormatter::clear();
	Notes::clear();
}

bool isProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnCloseProcess()
{
	if(isProcessOnExit())
	{
		OnExit();
	}
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
			
			// --- Notes

		case 1 :
			Notes_Create_note(pResult, pParams);
			break;

	}
}

// ------------------------------------- Notes ------------------------------------

#pragma mark -

void Notes_Create_note(sLONG_PTR *pResult, PackagePtr pParams)
{
	Notes::createNote(pParams, pResult);
}

