/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Notes
 #	author : miyako
 #	2015/11/25
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
        case kInitPlugin :
        case kServerInitPlugin :            
            OnStartup();
            break;
        case kCloseProcess :            
            OnCloseProcess();
            break;
// --- Query

		case 1 :
			Notes_GET_NOTES(pResult, pParams);
			break;

		case 2 :
			Notes_GET_ATTACHMENTS(pResult, pParams);
			break;

// --- Data

		case 3 :
			Notes_GET_DATA(pResult, pParams);
			break;

// --- Notification

		case 4 :
			Notes_SET_NOTIFICATION_METHOD(pResult, pParams);
			break;

		case 5 :
			Notes_Get_notification_method(pResult, pParams);
			break;

// --- Data

		case 6 :
			Notes_GET_PREVIEWS(pResult, pParams);
			break;

// --- App

		case 7 :
			Notes_LAUNCH(pResult, pParams);
			break;

		case 8 :
			Notes_TERMINATE(pResult, pParams);
			break;

	}
}

#pragma mark -

namespace Notes
{
    NotesApplication *app = [SBApplication applicationWithBundleIdentifier:@"com.apple.Notes"];

    NSUInteger version = 0;
    NSString *path;
    NSString *mediaFolderPath;
    NSString *monitorFolderPath;
    
    NSString *monitorFolderPathCloudKit = nil;
    
    //select all notes whose folder is not Recently Deleted, not marked for deletion, modification date is not null
    
    NSString *SQL_GET_NOTES = @"SELECT\n\
ZICCLOUDSYNCINGOBJECT.Z_PK,\n\
ZICCLOUDSYNCINGOBJECT.ZIDENTIFIER,\n\
ZICCLOUDSYNCINGOBJECT.ZTITLE1,\n\
ZICCLOUDSYNCINGOBJECT.ZCREATIONDATE,\n\
ZICCLOUDSYNCINGOBJECT.ZMODIFICATIONDATE1,\n\
Z_12NOTES.Z_12FOLDERS,\n\
_ZICCLOUDSYNCINGOBJECT.ZIDENTIFIER,\n\
_ZICCLOUDSYNCINGOBJECT.ZTITLE2\n\
FROM ZICCLOUDSYNCINGOBJECT,\n\
Z_12NOTES,\n\
ZICCLOUDSYNCINGOBJECT AS _ZICCLOUDSYNCINGOBJECT,\n\
ZICCLOUDSYNCINGOBJECT AS __ZICCLOUDSYNCINGOBJECT\n\
WHERE ZICCLOUDSYNCINGOBJECT.ZMARKEDFORDELETION = 0\n\
AND ZICCLOUDSYNCINGOBJECT.ZMODIFICATIONDATE1 > ?\n\
AND Z_12NOTES.Z_9NOTES = ZICCLOUDSYNCINGOBJECT.Z_PK\n\
AND __ZICCLOUDSYNCINGOBJECT.ZTITLE2 = \"Recently Deleted\"\n\
AND Z_12NOTES.Z_12FOLDERS != __ZICCLOUDSYNCINGOBJECT.Z_PK\n\
AND _ZICCLOUDSYNCINGOBJECT.Z_PK = Z_12NOTES.Z_12FOLDERS;";

    //same as above, with folder id

    NSString *SQL_GET_FOLDER_NOTES = @"SELECT\n\
ZICCLOUDSYNCINGOBJECT.Z_PK,\n\
ZICCLOUDSYNCINGOBJECT.ZIDENTIFIER,\n\
ZICCLOUDSYNCINGOBJECT.ZTITLE1,\n\
ZICCLOUDSYNCINGOBJECT.ZCREATIONDATE,\n\
ZICCLOUDSYNCINGOBJECT.ZMODIFICATIONDATE1,\n\
Z_12NOTES.Z_12FOLDERS,\n\
_ZICCLOUDSYNCINGOBJECT.ZIDENTIFIER,\n\
_ZICCLOUDSYNCINGOBJECT.ZTITLE2\n\
FROM ZICCLOUDSYNCINGOBJECT,\n\
Z_12NOTES,\n\
ZICCLOUDSYNCINGOBJECT AS _ZICCLOUDSYNCINGOBJECT,\n\
ZICCLOUDSYNCINGOBJECT AS __ZICCLOUDSYNCINGOBJECT\n\
WHERE ZICCLOUDSYNCINGOBJECT.ZMARKEDFORDELETION = 0\n\
AND ZICCLOUDSYNCINGOBJECT.ZMODIFICATIONDATE1 > ?\n\
AND _ZICCLOUDSYNCINGOBJECT.ZIDENTIFIER = ? \
AND Z_12NOTES.Z_9NOTES = ZICCLOUDSYNCINGOBJECT.Z_PK\n\
AND __ZICCLOUDSYNCINGOBJECT.ZTITLE2 = \"Recently Deleted\"\n\
AND Z_12NOTES.Z_12FOLDERS != __ZICCLOUDSYNCINGOBJECT.Z_PK\n\
AND _ZICCLOUDSYNCINGOBJECT.Z_PK = Z_12NOTES.Z_12FOLDERS;";

    //the data is raw (not html, even after gunzip)

    NSString *SQL_GET_DATA = @"SELECT\n\
ZICNOTEDATA.ZDATA,ZICNOTEDATA.ZNOTE\n\
FROM ZICCLOUDSYNCINGOBJECT, ZICNOTEDATA\n\
WHERE ZICCLOUDSYNCINGOBJECT.ZIDENTIFIER = ?\n\
AND ZICNOTEDATA.ZNOTE = ZICCLOUDSYNCINGOBJECT.Z_PK;";

    //all attachments for note

    NSString *SQL_GET_NOTE_ATTACHMENTS = @"SELECT\n\
ZICCLOUDSYNCINGOBJECT.Z_PK,\n\
ZICCLOUDSYNCINGOBJECT.ZFILESIZE,\n\
ZICCLOUDSYNCINGOBJECT.ZTITLE,\n\
ZICCLOUDSYNCINGOBJECT.ZTYPEUTI,\n\
_ZICCLOUDSYNCINGOBJECT.ZIDENTIFIER,\n\
_ZICCLOUDSYNCINGOBJECT.ZFILENAME,\n\
ZICCLOUDSYNCINGOBJECT.ZORIENTATION\n\
FROM ZICCLOUDSYNCINGOBJECT,\n\
ZICCLOUDSYNCINGOBJECT AS _ZICCLOUDSYNCINGOBJECT,\n\
ZICCLOUDSYNCINGOBJECT AS __ZICCLOUDSYNCINGOBJECT\n\
WHERE __ZICCLOUDSYNCINGOBJECT.ZIDENTIFIER = ?\n\
AND _ZICCLOUDSYNCINGOBJECT.Z_PK = ZICCLOUDSYNCINGOBJECT.ZMEDIA\n\
AND _ZICCLOUDSYNCINGOBJECT.ZMARKEDFORDELETION = 0\n\
AND ZICCLOUDSYNCINGOBJECT.ZNOTE = __ZICCLOUDSYNCINGOBJECT.Z_PK;";
}



void generateUuid(C_TEXT &returnValue)
{
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
    returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
    CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
    NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
    returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
}

process_number_t MONITOR_FOLDER_METHOD_PROCESS_ID;
process_stack_size_t MONITOR_FOLDER_STACK_SIZE;
process_name_t MONITOR_FOLDER_METHOD_PROCESS_NAME;

method_id_t MONITOR_FOLDER_METHOD_ID;

bool MONITOR_FOLDER_METHOD_PROCESS_SHOULD_TERMINATE;
bool MONITOR_FOLDER_METHOD_PROCESS_SHOULD_EXECUTE_METHOD;

C_TEXT MONITOR_FOLDER_EVENT_PATH;
C_TEXT MONITOR_FOLDER_WATCH_METHOD;
C_TEXT MONITOR_FOLDER_METHOD_PROCESS_NAME_INTERNAL;

NSTimeInterval MONITOR_LATENCY;
FSEventStreamRef MONITOR_STREAM;

void gotEvent(FSEventStreamRef stream,
                 void *callbackInfo, 
                 size_t numEvents, 
                 void *eventPaths, 
                 const FSEventStreamEventFlags eventFlags[], 
                 const FSEventStreamEventId eventIds[]
                 ) {
                 
    NSArray *paths = (NSArray *)(CFArrayRef)eventPaths;         
    NSMutableString *pathsString = [[NSMutableString alloc]init];
    
    for(uint32_t i = 0; i < [paths count] ; ++i)
    {
        if(i)
        {
            [pathsString appendString:@"\n"];    
        }
        [pathsString appendString:(NSString *)[paths objectAtIndex:i]];
    }
               
    MONITOR_FOLDER_EVENT_PATH.setUTF16String(pathsString);
    [pathsString release];
    
    listenerLoopExecute();
}

#pragma mark -

bool IsProcessOnExit()
{
    C_TEXT name;
    PA_long32 state, time;
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
    CUTF16String procName(name.getUTF16StringPtr());
    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
    return (!procName.compare(exitProcName));
}

#pragma mark Event

void OnStartup()
{
    NSArray *domainPaths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
    NSString *libraryFolder = [domainPaths objectAtIndex:0];
    
    NSString *noteFolderPathV7 = [[[libraryFolder
        stringByAppendingPathComponent:@"Group Containers"]
        stringByAppendingPathComponent:@"group.com.apple.notes"]
        stringByAppendingPathComponent:@"NoteStore.sqlite"];
    
    NSString *monitorFolderPathCloudKit = [[[[libraryFolder
        stringByAppendingPathComponent:@"Containers"]
        stringByAppendingPathComponent:@"com.apple.Notes"]
        stringByAppendingPathComponent:@"Data"]
        stringByAppendingPathComponent:@"CloudKit"];

    /*
    NSString *noteFolderPathV6 = [[[[[[libraryFolder
        stringByAppendingPathComponent:@"Containers"]
        stringByAppendingPathComponent:@"group.com.apple.notes"]
        stringByAppendingPathComponent:@"Data"]
        stringByAppendingPathComponent:@"Library"]
        stringByAppendingPathComponent:@"Notes"]
        stringByAppendingPathComponent:@"NotesV6.storedata"];
    
    NSString *noteFolderPathV5 = [[[[[[libraryFolder
        stringByAppendingPathComponent:@"Containers"]
        stringByAppendingPathComponent:@"group.com.apple.notes"]
        stringByAppendingPathComponent:@"Data"]
        stringByAppendingPathComponent:@"Library"]
        stringByAppendingPathComponent:@"Notes"]
        stringByAppendingPathComponent:@"NotesV5.storedata"];
    
    NSString *noteFolderPathV4 = [[[[[[libraryFolder
        stringByAppendingPathComponent:@"Containers"]
        stringByAppendingPathComponent:@"group.com.apple.notes"]
        stringByAppendingPathComponent:@"Data"]
        stringByAppendingPathComponent:@"Library"]
        stringByAppendingPathComponent:@"Notes"]
        stringByAppendingPathComponent:@"NotesV4.storedata"];

     */
    NSString *mediaFolderPath = [[[libraryFolder
        stringByAppendingPathComponent:@"Group Containers"]
        stringByAppendingPathComponent:@"group.com.apple.notes"]
        stringByAppendingPathComponent:@"Media"];
    
    NSFileManager *fileManager = [[NSFileManager alloc]init];
    
    if([fileManager fileExistsAtPath:noteFolderPathV7 isDirectory:NULL])
    {
        Notes::version = 7;
        Notes::path = [NSString stringWithString:noteFolderPathV7];
        Notes::monitorFolderPath = [Notes::path stringByDeletingLastPathComponent];
        Notes::monitorFolderPathCloudKit = [NSString stringWithString:monitorFolderPathCloudKit];
    }
    /*
    else
    if([fileManager fileExistsAtPath:noteFolderPathV6 isDirectory:NULL])
    {
        Notes::version = 6;
        Notes::path = [NSString stringWithString:noteFolderPathV6];
        Notes::monitorFolderPath = [Notes::path stringByDeletingLastPathComponent];
    }else
    if([fileManager fileExistsAtPath:noteFolderPathV5 isDirectory:NULL])
    {
        Notes::version = 5;
        Notes::path = [NSString stringWithString:noteFolderPathV5];
        Notes::monitorFolderPath = [Notes::path stringByDeletingLastPathComponent];
    }else
    if([fileManager fileExistsAtPath:noteFolderPathV4 isDirectory:NULL])
    {
        Notes::version = 4;
        Notes::path = [NSString stringWithString:noteFolderPathV4];
        Notes::monitorFolderPath = [Notes::path stringByDeletingLastPathComponent];
    }
     */
    Notes::mediaFolderPath = [NSString stringWithString:mediaFolderPath];
    
    [fileManager release];
    
    NSLog(@"notes path:%@", Notes::path);
    
    CUTF8String name((const uint8_t *)"$NOTES");
    MONITOR_FOLDER_METHOD_PROCESS_NAME_INTERNAL.setUTF8String(&name);
    MONITOR_FOLDER_METHOD_PROCESS_NAME = (process_name_t)MONITOR_FOLDER_METHOD_PROCESS_NAME_INTERNAL.getUTF16StringPtr();
        
    MONITOR_FOLDER_METHOD_PROCESS_ID = 0;
    MONITOR_FOLDER_STACK_SIZE = 0;
    MONITOR_FOLDER_METHOD_ID = 0;
}

void OnCloseProcess()
{
    if(IsProcessOnExit())
    {
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listenerLoopFinish, NULL); 
    }
}

#pragma mark Listener

void listenerLoop()
{
    MONITOR_FOLDER_METHOD_PROCESS_SHOULD_EXECUTE_METHOD = false;
    MONITOR_FOLDER_METHOD_PROCESS_SHOULD_TERMINATE = false;
        
    while(!MONITOR_FOLDER_METHOD_PROCESS_SHOULD_TERMINATE)
    { 
        PA_YieldAbsolute();
        
        if(MONITOR_FOLDER_METHOD_PROCESS_SHOULD_EXECUTE_METHOD)
        {
            MONITOR_FOLDER_METHOD_PROCESS_SHOULD_EXECUTE_METHOD = false;
            
            C_TEXT processName;
            generateUuid(processName);
            PA_NewProcess((void *)listenerLoopExecuteMethod, 
                          MONITOR_FOLDER_STACK_SIZE, 
                          (PA_Unichar *)processName.getUTF16StringPtr());        

        }

        if(!MONITOR_FOLDER_METHOD_PROCESS_SHOULD_TERMINATE)
        {
            PA_FreezeProcess(PA_GetCurrentProcessNumber());  
        }else
        {
            MONITOR_FOLDER_METHOD_PROCESS_ID = 0;
        }
    }
    PA_KillProcess();
}

void listenerLoopStart()
{
    if(!MONITOR_FOLDER_METHOD_PROCESS_ID)
    {
        MONITOR_FOLDER_METHOD_PROCESS_ID = PA_NewProcess((void *)listenerLoop, 
                                                         MONITOR_FOLDER_STACK_SIZE, 
                                                         MONITOR_FOLDER_METHOD_PROCESS_NAME);  
        
//        NSArray *paths = [NSArray arrayWithObjects:Notes::monitorFolderPath, Notes::monitorFolderPathCloudKit, nil];
        NSArray *paths = [NSArray arrayWithObjects:Notes::monitorFolderPathCloudKit, nil];
        
        FSEventStreamContext context = {0, NULL, NULL, NULL, NULL};
        NSTimeInterval latency = MONITOR_LATENCY;
        
        MONITOR_STREAM = FSEventStreamCreate(NULL,
            (FSEventStreamCallback)gotEvent,
            &context,
            (CFArrayRef)paths,
            kFSEventStreamEventIdSinceNow, 
            (CFAbsoluteTime)latency,
            kFSEventStreamCreateFlagUseCFTypes
            | kFSEventStreamCreateFlagFileEvents
            | kFSEventStreamCreateFlagNoDefer
            | kFSEventStreamCreateFlagIgnoreSelf
        );
          
        FSEventStreamScheduleWithRunLoop(MONITOR_STREAM, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
        FSEventStreamStart(MONITOR_STREAM);
    }
}

void listenerLoopFinish()
{
    if(MONITOR_FOLDER_METHOD_PROCESS_ID)
    {
        //uninstall handler
        FSEventStreamStop(MONITOR_STREAM);
        FSEventStreamUnscheduleFromRunLoop (MONITOR_STREAM, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
        FSEventStreamInvalidate(MONITOR_STREAM);
        FSEventStreamRelease(MONITOR_STREAM);
        MONITOR_STREAM = 0;
        //set flags
        MONITOR_FOLDER_METHOD_PROCESS_SHOULD_TERMINATE = true;
        MONITOR_FOLDER_METHOD_PROCESS_SHOULD_EXECUTE_METHOD = false;
        PA_YieldAbsolute();  
        //tell listener to die      
//        while(MONITOR_FOLDER_METHOD_PROCESS_ID)
//        {
//            PA_YieldAbsolute();
            PA_UnfreezeProcess(MONITOR_FOLDER_METHOD_PROCESS_ID);
//        }
    }
} 

void listenerLoopExecute()
{
    MONITOR_FOLDER_METHOD_PROCESS_SHOULD_TERMINATE = false;
    MONITOR_FOLDER_METHOD_PROCESS_SHOULD_EXECUTE_METHOD = true;
    PA_UnfreezeProcess(MONITOR_FOLDER_METHOD_PROCESS_ID);
}

void listenerLoopExecuteMethod()
{
    if(MONITOR_FOLDER_METHOD_ID)
    {
        PA_Variable	params[1];
        params[0] = PA_CreateVariable(eVK_Unistring);
        
//        PA_Unistring path = PA_CreateUnistring((PA_Unichar *)MONITOR_FOLDER_EVENT_PATH.getUTF16StringPtr());
//        PA_SetStringVariable(&params[0], &path);
        PA_SetUnistring( (&(params[0].uValue.fString)), (PA_Unichar *)MONITOR_FOLDER_EVENT_PATH.getUTF16StringPtr());

        PA_ExecuteMethodByID(MONITOR_FOLDER_METHOD_ID, params, 1);
        
//        PA_DisposeUnistring(&path);

        PA_ClearVariable(&params[0]);
    }
    
}

#pragma mark Notes

// ------------------------------------- Query ------------------------------------


void Notes_GET_NOTES(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_REAL in_anchor;
	C_TEXT in_folder;
	ARRAY_TEXT out_id;
	ARRAY_TEXT out_title;
	ARRAY_REAL out_created;
	ARRAY_REAL out_modified;
	ARRAY_TEXT out_folder_id;
	ARRAY_TEXT out_folder_title;

	in_anchor.fromParamAtIndex(pParams, 1);
	in_folder.fromParamAtIndex(pParams, 2);

    if(Notes::version)
    {
        in_anchor.fromParamAtIndex(pParams, 1);
        in_folder.fromParamAtIndex(pParams, 2);

        out_id.setSize(1);
        out_title.setSize(1);
        out_created.setSize(1);
        out_modified.setSize(1);
        out_folder_id.setSize(1);
        out_folder_title.setSize(1);

        double in_anchor_v = in_anchor.getDoubleValue();
        CUTF8String in_folder_v;
        in_folder.copyUTF8String(&in_folder_v);
        
        sqlite3 *notesStore = NULL;
        
        int err = sqlite3_open([Notes::path UTF8String], &notesStore);
        
        if(err != SQLITE_OK)
        {
            NSLog(@"failed to open sqlite database at:%@", Notes::path);
        }else
        {
            sqlite3_stmt *sql = NULL;
            if(!in_folder_v.length())
            {
                err = sqlite3_prepare_v2(notesStore, [Notes::SQL_GET_NOTES UTF8String], 1024, &sql, NULL);
            }else
            {
                err = sqlite3_prepare_v2(notesStore, [Notes::SQL_GET_FOLDER_NOTES UTF8String], 1024, &sql, NULL);
            }
            if(err != SQLITE_OK)
            {
                NSLog(@"failed to prepare sqlite statement");
            }else
            {
                sqlite3_bind_double(sql, 1, in_anchor_v);
                if(in_folder_v.length())
                {
                    sqlite3_bind_text(sql, 2, (const char *)in_folder_v.c_str(), in_folder_v.length(), NULL);
                }
                
                while(SQLITE_ROW == (err = sqlite3_step(sql))){
//                    int note_pk = sqlite3_column_int(sql, 0);
                    CUTF8String note_id((uint8_t *)sqlite3_column_text(sql, 1));
                    CUTF8String note_title = ((uint8_t *)sqlite3_column_text(sql, 2));
                    double note_created = sqlite3_column_double(sql, 3);
                    double note_modified = sqlite3_column_double(sql, 4);
//                    int folder_name_pk = sqlite3_column_int(sql, 5);
                    CUTF8String folder_id = ((uint8_t *)sqlite3_column_text(sql, 6));
                    CUTF8String folder_title = ((uint8_t *)sqlite3_column_text(sql, 7));
                    out_id.appendUTF8String(&note_id);
                    out_title.appendUTF8String(&note_title);
                    out_created.appendDoubleValue(note_created);
                    out_modified.appendDoubleValue(note_modified);
                    out_folder_id.appendUTF8String(&folder_id);
                    out_folder_title.appendUTF8String(&folder_title);
                }
                
                sqlite3_finalize(sql);
            }
            sqlite3_close(notesStore);
        }
        
    }

	out_id.toParamAtIndex(pParams, 3);
	out_title.toParamAtIndex(pParams, 4);
	out_created.toParamAtIndex(pParams, 5);
	out_modified.toParamAtIndex(pParams, 6);
	out_folder_id.toParamAtIndex(pParams, 7);
	out_folder_title.toParamAtIndex(pParams, 8);
}

void Notes_GET_ATTACHMENTS(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT in_note;
	ARRAY_TEXT out_id;
	ARRAY_TEXT out_title;
	ARRAY_TEXT out_file_name;
	ARRAY_TEXT out_file_type;
	ARRAY_TEXT out_file_path;
	ARRAY_LONGINT out_file_size;

	in_note.fromParamAtIndex(pParams, 1);
    CUTF8String in_note_v;
    in_note.copyUTF8String(&in_note_v);

    if(Notes::version)
    {
        sqlite3 *notesStore = NULL;
        
        out_id.setSize(1);
        out_title.setSize(1);
        out_file_name.setSize(1);
        out_file_type.setSize(1);
        out_file_path.setSize(1);
        out_file_size.setSize(1);
        
        int err = sqlite3_open([Notes::path UTF8String], &notesStore);
        
        if(err != SQLITE_OK)
        {
            NSLog(@"failed to open sqlite database at:%@", Notes::path);
        }else
        {
            sqlite3_stmt *sql = NULL;
            err = sqlite3_prepare_v2(notesStore, [Notes::SQL_GET_NOTE_ATTACHMENTS UTF8String], 1024, &sql, NULL);
            if(err != SQLITE_OK)
            {
                NSLog(@"failed to prepare sqlite statement:%@", Notes::SQL_GET_NOTE_ATTACHMENTS);
            }else
            {
                sqlite3_bind_text(sql, 1, (const char *)in_note_v.c_str(), in_note_v.length(), NULL);
                
                while(SQLITE_ROW == (err = sqlite3_step(sql))){
//                    int file_pk = sqlite3_column_int(sql, 0);
                    int file_size = sqlite3_column_int(sql, 1);
                    out_file_size.appendIntValue(file_size);
                    
                    uint8_t *_file_title = (uint8_t *)sqlite3_column_text(sql, 2);
                    uint8_t *_file_type = (uint8_t *)sqlite3_column_text(sql, 3);
                    uint8_t *_file_id = (uint8_t *)sqlite3_column_text(sql, 4);
                    uint8_t *_file_name = (uint8_t *)sqlite3_column_text(sql, 5);
                    /*
                    uint8_t *_orientation = (uint8_t *)sqlite3_column_text(sql, 6);
                    CUTF8String orientation = _orientation ? CUTF8String(_orientation) : (uint8_t *)"";
                    if(!orientation.compare((uint8_t *)"0"))
                    {
                        NSLog(@"orientation:%s", orientation.c_str());
                    }
                     */
                    CUTF8String file_title = _file_title ? CUTF8String(_file_title) : (uint8_t *)"";
                    CUTF8String file_type = _file_type ? CUTF8String(_file_type) : (uint8_t *)"";
                    CUTF8String file_id = _file_id ? CUTF8String(_file_id) : (uint8_t *)"";
                    CUTF8String file_name = _file_name ? CUTF8String(_file_name) : (uint8_t *)"";
                    
                    out_title.appendUTF8String(&file_title);
                    out_file_type.appendUTF8String(&file_type);
                    out_id.appendUTF8String(&file_id);
                    out_file_name.appendUTF8String(&file_name);
                    
                    NSString *file_path = [[Notes::mediaFolderPath
                    stringByAppendingPathComponent:[NSString stringWithUTF8String:(const char *)file_id.c_str()]]
                    stringByAppendingPathComponent:[NSString stringWithUTF8String:(const char *)file_name.c_str()]];
                    
                    NSURL *url = [[NSURL alloc]initFileURLWithPath:file_path];
                    if(url)
                    {
                        NSString *_file_path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLHFSPathStyle);
                        out_file_path.appendUTF16String(_file_path);
                        [_file_path release];
                    }else
                    {
                        out_file_path.appendUTF16String(@"");
                    }
 
                }
            
            }
            sqlite3_close(notesStore);
        }
        
    }
	
	out_id.toParamAtIndex(pParams, 2);
    out_title.toParamAtIndex(pParams, 3);
	out_file_name.toParamAtIndex(pParams, 4);
	out_file_type.toParamAtIndex(pParams, 5);
	out_file_path.toParamAtIndex(pParams, 6);
	out_file_size.toParamAtIndex(pParams, 7);
}

// ------------------------------------- Data -------------------------------------


void Notes_GET_DATA(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT in_id;
	C_TEXT out_name;
	C_TEXT out_text;
	C_BLOB out_data;

	in_id.fromParamAtIndex(pParams, 1);

	if(Notes::version)
    {
        in_id.fromParamAtIndex(pParams, 1);
        CUTF8String in_id_v;
        in_id.copyUTF8String(&in_id_v);
        
        sqlite3 *notesStore = NULL;
        
        int err = sqlite3_open([Notes::path UTF8String], &notesStore);
        
        if(err != SQLITE_OK)
        {
            NSLog(@"failed to open sqlite database at:%@", Notes::path);
        }else
        {
            sqlite3_stmt *sql = NULL;
            err = sqlite3_prepare_v2(notesStore, [Notes::SQL_GET_DATA UTF8String], 1024, &sql, NULL);
            if(err != SQLITE_OK)
            {
                NSLog(@"failed to prepare sqlite statement");
            }else
            {
                sqlite3_bind_text(sql, 1, (const char *)in_id_v.c_str(), in_id_v.length(), NULL);
                
                if(SQLITE_ROW == sqlite3_step(sql))
                {
                    //the gunzipped raw data is proprietary (not html)
                    int len = sqlite3_column_bytes(sql, 0);
                    int note_pk = sqlite3_column_int(sql, 1);
                    const void *ptr = sqlite3_column_blob(sql, 0);
                    
                    //ask notes.app to interpret it
                    if(Notes::app)
                    {
                        SBElementArray *notes = [Notes::app notes];
                        if([notes count])
                        {
                            NotesNote *note = [notes objectAtIndex:0];
                            NSString *note_uuid = [note id];
                            NSError *error = nil;
                            NSString *_thePattern = @"\\d+$";
                            NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:_thePattern options:0 error:&error];
                            NSString *note_uuid_path = [regex stringByReplacingMatchesInString:note_uuid options:0 range:NSMakeRange(0, [note_uuid length]) withTemplate:@""];
                            NSString *_theId = [note_uuid_path stringByAppendingString:[[NSNumber numberWithInt:note_pk]stringValue]];
                            
                            NotesNote *_note = [notes objectWithID:_theId];
                            if([_note id])
                            {
                                out_name.setUTF16String([_note name]);
                                out_text.setUTF16String([_note body]);
                            }
                        }
                    }
                    //also the raw data as blob
                    std::vector<uint8_t>_buf(0);
                    gzipInflate(ptr, len, _buf);
                    out_data.setBytes(&_buf[0], _buf.size());
                }
                
            }
            
            sqlite3_close(notesStore);
        }
    
    }

	out_name.toParamAtIndex(pParams, 2);
	out_text.toParamAtIndex(pParams, 3);
	out_data.toParamAtIndex(pParams, 4);
}

// --------------------------------- Notification ---------------------------------


void Notes_SET_NOTIFICATION_METHOD(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;

	Param1.fromParamAtIndex(pParams, 1);

    if(!Param1.getUTF16Length())
    {
        if(MONITOR_FOLDER_WATCH_METHOD.getUTF16Length())
        {
            MONITOR_FOLDER_WATCH_METHOD.setUTF16String(Param1.getUTF16StringPtr(), Param1.getUTF16Length());
            MONITOR_FOLDER_METHOD_ID = 0;
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listenerLoopFinish, NULL);
        }

    }else
    {
        NSLog(@"monitor path:%@", Notes::monitorFolderPath);

        method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param1.getUTF16StringPtr());
        
        if(methodId)
        {
            if(methodId != MONITOR_FOLDER_METHOD_ID)
            {
                MONITOR_FOLDER_WATCH_METHOD.setUTF16String(Param1.getUTF16StringPtr(), Param1.getUTF16Length());
                MONITOR_FOLDER_METHOD_ID = methodId;
                MONITOR_LATENCY = 1.0;
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listenerLoopFinish, NULL);
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listenerLoopStart, NULL);
            }
            
        }
      
    }
    
}

void Notes_Get_notification_method(sLONG_PTR *pResult, PackagePtr pParams)
{
	MONITOR_FOLDER_WATCH_METHOD.setReturn(pResult);
}

// ------------------------------------- Data -------------------------------------


void Notes_GET_PREVIEWS(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT in_id;
	ARRAY_TEXT out_path;

	in_id.fromParamAtIndex(pParams, 1);

	// --- write the code of Notes_GET_PREVIEWS here...

	out_path.toParamAtIndex(pParams, 2);
}

#pragma mark GZ

//based on http://windrealm.org/tutorials/decompress-gzip-stream.php

bool gzipInflate(const void *ptr, int len, std::vector<uint8_t> &uncompressedBytes)
{
    uncompressedBytes.clear();
    
    if (len == 0)
    {
        return true;
    }

    unsigned full_length = len;
    unsigned half_length = len / 2;
    unsigned uncompLength = full_length;
    uint8_t * uncomp = (uint8_t *)calloc(sizeof(uint8_t), uncompLength);
    z_stream strm;
    strm.next_in = (Bytef *)ptr;
    strm.avail_in = len;
    strm.total_out = 0;
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;

    bool done = false;

    if (inflateInit2(&strm, (16+MAX_WBITS)) != Z_OK)
    {
        free(uncomp);
        return false;  
    }
  
    while (!done)
    {
        PA_YieldAbsolute();
        // If our output buffer is too small
        if (strm.total_out >= uncompLength)
        {
            // Increase size of output buffer
            uint8_t *uncomp2 = (uint8_t *) calloc(sizeof(uint8_t), uncompLength + half_length);
            memcpy(uncomp2, uncomp, uncompLength);
            uncompLength += half_length;
            free(uncomp);
            uncomp = uncomp2;
        }  

        strm.next_out = (Bytef *)(uncomp + strm.total_out);
        strm.avail_out = uncompLength - strm.total_out;
        
        // Inflate another chunk.  
        int err = inflate (&strm, Z_SYNC_FLUSH);  
        if (err == Z_STREAM_END) done = true;  
        else if (err != Z_OK)
        {
            break;
        }
    }
    if (inflateEnd (&strm) != Z_OK)
    {
        free(uncomp);
        return false;  
    }
  
  uncompressedBytes.resize(strm.total_out);
  
  memcpy(&uncompressedBytes[0], &uncomp[0], strm.total_out);

  free(uncomp);
  
  return true;
}

#pragma mark App

void Notes_LAUNCH(sLONG_PTR *pResult, PackagePtr pParams)
{
    NSString *bundleIdentifier = @"com.apple.Notes";
    NSWorkspaceLaunchOptions options = NSWorkspaceLaunchAndHide|NSWorkspaceLaunchAsync|NSWorkspaceLaunchWithoutActivation|NSWorkspaceLaunchWithoutActivation;
    NSAppleEventDescriptor *descriptor = [NSAppleEventDescriptor nullDescriptor];

    [[NSWorkspace sharedWorkspace]launchAppWithBundleIdentifier:bundleIdentifier
    options:options
    additionalEventParamDescriptor:descriptor
    launchIdentifier:(NSNumber **)NULL];
}

void Notes_TERMINATE(sLONG_PTR *pResult, PackagePtr pParams)
{
	NSArray *runningApplications = [NSRunningApplication runningApplicationsWithBundleIdentifier:@"com.apple.Notes"];
    if([runningApplications count])
    {
        for(NSUInteger i = 0; i < [runningApplications count]; ++i)
        {
            [(NSRunningApplication *)[runningApplications objectAtIndex:i]terminate];
        }
    }

}

